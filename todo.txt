1. Build the app with the proper bootloader configuration. Use the provided mechanisms to compile for QSPI boot. For example, in a Makefile project add APP_TYPE = BOOT_QSPI
github.com
 (or manually define BOOT_APP and use the QSPI linker). This ensures the linker addresses are correct (which you’ve done) and that the startup code knows it’s running under a bootloader (skipping any re-init that could disrupt execution). Double-check that your compiler flags include -DBOOT_APP. This single step is critical to prevent the app from clobbering the bootloader’s setup. 

 2. Reflash or update the Daisy bootloader stub to the latest version. Since you’re using the “standard mechanism,” make sure it’s the official bootloader that matches your libDaisy. The fact that the device stays in DFU mode suggests the stub isn’t handing off to the app. Use the latest libDaisy to make program-boot again, so you get any recent fixes. (The Daisy bootloader has evolved; for example, newer versions leave QSPI sectors [0x90000000–0x9003FFFF] empty and jump to 0x90040000
github.com
. An outdated stub might not do that correctly.) After flashing, confirm the bootloader’s LED behavior: on reset, it should blink briefly then stop when it jumps to your app.

3. Verify the QSPI flash contents and vector table. After flashing your app to QSPI, the first 8 bytes at 0x90040000 should be: [Initial_SP, Reset_Handler]. Using a debugger or by reading back via the bootloader (if possible), ensure these values look plausible (Initial_SP in the 0x200xxxxx or 0x240xxxxx range, Reset_Handler = 0x9004xxxx). If they’re all 0xFF or 0x00, the app didn’t flash correctly. In that case, try the DFU upload again or use an alternate method (e.g. an ST-Link with OpenOCD) to program the QSPI. The Daisy bootloader documentation notes that the DFU method will automatically target the right address when APP_TYPE is set
github.com
, so use make program-dfu or make program-app rather than manual dfu-util commands to avoid mistakes.
4. Confirm that the app does not re-initialize QSPI or clocks in code. Your branch’s DaisySeed::Init() already handles this properly by skipping QSPI init when running from QSPI
github.com
. Just be sure you call hw.Init() early in main() (which your InitializeHardware() does, calling hw.Init()
github.com
). That ensures System::Init runs with skip_clocks=true and doesn’t disturb the clock tree. Also, do not manually call System::JumpToQspi() or similar – that’s intended for the bootloader, not for the app.